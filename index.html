<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>River Installation • The River Bride</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- p5.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/p5.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,400;0,600;1,400;1,600&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg: #0b0d10;
      --fg: #e8eef2;
      --muted: #a9b7c0;
      --accent: #a1e3a1;
      --btn-bg: #14181d;
      --btn-fg: #e8eef2;
      --btn-border: #2a323b;
      --btn-hover: #1b2127;
      --card: #101419;
      --card-border: #20262d;
    }
    html, body {
      margin: 0; padding: 0; height: 100%;
      background: var(--bg); color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
    }
    .wrap {
      min-height: 100%;
      display: grid;
      grid-template-rows: auto 1fr auto;
    }
    header, footer {
      padding: 16px 20px;
      border-bottom: 1px solid var(--card-border);
    }
    footer { border-top: 1px solid var(--card-border); border-bottom: none; color: var(--muted); }
    .title {
      display: flex; align-items: center; gap: 16px; flex-wrap: wrap;
    }
    .title h1 { margin: 0; font-size: clamp(20px, 3vw, 28px); letter-spacing: 0.3px; }
    .meta {
      display: flex; gap: 14px; flex-wrap: wrap; color: var(--muted); font-size: 0.95rem;
    }
    .controls {
      margin-left: auto; display: flex; gap: 10px;
    }
    .btn {
      appearance: none; cursor: pointer; user-select: none;
      padding: 10px 14px; border-radius: 10px;
      border: 1px solid var(--btn-border);
      background: var(--btn-bg); color: var(--btn-fg);
      transition: background 120ms ease, transform 80ms ease;
      font-weight: 600; letter-spacing: 0.2px;
    }
    .btn:hover { background: var(--btn-hover); }
    .btn:active { transform: translateY(1px); }

    .canvas-card {
      margin: 16px 16px 24px;
      border: 1px solid var(--card-border);
      border-radius: 14px;
      background: linear-gradient(180deg, #0f1318, #0b0f13);
      box-shadow: 0 10px 24px rgba(0,0,0,0.25);
      overflow: hidden;
    }
    .canvas-head {
      display: flex; align-items: center; justify-content: space-between;
      gap: 12px; padding: 10px 12px;
      border-bottom: 1px solid var(--card-border);
      color: var(--muted); font-size: 0.95rem;
    }
    #sketchMount {
      position: relative;
      width: 100%;
      height: min(72vh, 72vw); 
      outline: none;
    }
    #sketchMount:fullscreen {
      width: 100vw !important;
      height: 100vh !important;
      margin: 0;
      border-radius: 0;
    }
    #sketchMount {
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }


    .hint {
      padding: 6px 12px 12px; color: var(--muted); font-size: 0.92rem;
    }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1>River Installation</h1>
        <div class="meta">
          <span>Artist: <strong>Alyssa Barrack</strong></span>
          <span>Play: <strong>The River Bride</strong></span>
          <span>By: <strong>Marisela Treviño Orta</strong></span>
        </div>
        <div class="controls">
          <button id="btn-fullscreen" class="btn" type="button" aria-pressed="false">Enter Full Screen</button>
        </div>
      </div>
    </header>

    <main>
      <section class="canvas-card" aria-label="Interactive river visualization">
        <div class="canvas-head">
          <span>Autonomous river sketch (p5.js)</span>
          <span>Tip: use the Full Screen button for installations</span>
        </div>
        <div id="sketchMount" tabindex="0" role="img" aria-label="Animated river canvas"></div>
        <div class="hint">
          This visualization generates slow ripples and phrases on a time-based schedule.
        </div>
      </section>
    </main>

    <footer>
      © <span id="year"></span> Alyssa Barrack. Built with p5.js.
    </footer>
  </div>

  <script>
    // Footer year
    document.getElementById('year').textContent = new Date().getFullYear();

    /* =========================
       River Installation (autonomous)
       Single-file version for GitHub Pages
       ========================= */

    /* ------- TUNABLE SETTINGS ------- */
    const RIPPLE_MIN_INTERVAL_MS = 2600;   // shortest gap between ripples
    const RIPPLE_MAX_INTERVAL_MS = 5200;   // longest gap between ripples
    const RIPPLE_GROUP_CHANCE   = 0.35;    // chance to spawn a small cluster
    const RIPPLE_GROUP_SIZE_MIN = 2;
    const RIPPLE_GROUP_SIZE_MAX = 4;
    const RIPPLE_GROUP_SPREAD   = 28;      // px spread around a center when clustering

    const RIPPLE_GROWTH_PX_PER_FRAME = 0.65; // slower = more readable
    const RIPPLE_ALPHA_FADE_IN_MS  = 1600;   // text fade-in
    const RIPPLE_ALPHA_HOLD_MS     = 2600;   // hold duration
    const RIPPLE_ALPHA_FADE_OUT_MS = 2600;   // text fade-out

    const RIPPLE_STROKE_ALPHA = 90;
    const RIPPLE_TEXT_SIZE    = 16;
    const RIVER_HALF_WIDTH    = 200;

    /* ---------- Text styling & motion ---------- */
const FONT_FAMILY = 'Spectral, serif'; 
const TEXT_WEIGHT = 600;              
const TEXT_ITALIC = true;              

// Character motion parameters
const TEXT_WAVE_AMPLITUDE = 6;         // px vertical/lateral wobble
const TEXT_WAVE_SPEED     = 0.05;      // animation speed
const TEXT_SCATTER_IN     = 0.5;       // outward drift strength during fade-in
const TEXT_SCATTER_HOLD   = 0.8;       // during hold
const TEXT_SCATTER_OUT    = 1.6;       // during fade-out (more breakup)
const TEXT_CHAR_SPREAD    = 0.9;       // lateral spread along the line (0..1.5)
const TEXT_ROTATION_MAX   = 0.04;      // max per-char rotation (radians)

    /* -------------------------------- */

    const PHRASE_SETTINGS = { factsWeight: 0.35, brideWeight: 0.25, recentBuffer: 6 };

    const poeticLines = [
      "The river knows.","The river remembers.","What were you before?",
      "Floods and ebbs, you know its motion.","A name once spoken, lost downstream.",
      "Moonlight sparkles on the calm river.","The rain disrupts, the rain brings newness.",
      "Your hand writes circles the water won't forget.","Listen. The water tells its secrets.",
      "Branches kiss the surface, what roots lie beneath?","The channel curves, the same as your lost thoughts.",
      "To drift is to choose.","The water takes shape in your wondering.","The river changes in the rain."
    ];

    const riverFacts = [
      "The water here carries worlds of sediment, stories ground to silt.",
      "Take a gamble in the largest rainforest in the world.",
      "These waters cross 8 continents, expansive.",
      "So many species call these banks and waters home; new ones are always there to find, if one is brave enough to look.",
      "Who lives here? Who knows the land? Who was born here?",
      "The river supports 400 indigenous groups, and 300 indigenous languages.",
      "Stop taking these trees, they are integral to the safety of the planet.",
      "The rich canopy tells the story of the forest, and provides its temperature and humidity regulation.",
      "The Amazon once flowed in the opposite direction, towards the Pacific, until the Andes rose and reversed it.",
      "Sometimes even dolphin myths can die - global warming causes intensive droughts, harming the ecosystem and all creature that inhabit it."
    ];

    const brideFlavor = [
      "Promises ebb and flow, but the river always keeps them.",
      "Sisters hear different secrets in the same water.",
      "A veil of steam, a choice to drift.",
      "If a stranger rose from these waters, would you know his name?",
      "How do you treat the dolphins? They watch; they know.",
      "Nets catch fish, sometimes more.",
      "The current hesistates, and the current pulls.",
      "The floods await no one."
    ];

    let ripples = [];
    let riverMask = [];
    let nextRippleAt = 0;
    const recentPhrases = [];

    // Full Screen toggle
    const btnFs = document.getElementById('btn-fullscreen');
    btnFs.addEventListener('click', () => {
      const mount = document.getElementById('sketchMount');
      if (!document.fullscreenElement) {
        mount.requestFullscreen().catch(err => {
          console.error("Error attempting to enable full-screen mode:", err);
        });
      } else {
        document.exitFullscreen();
      }
    });

    document.addEventListener('fullscreenchange', () => {
      const isFs = !!document.fullscreenElement;
      btnFs.textContent = isFs ? "Exit Full Screen" : "Enter Full Screen";
      btnFs.setAttribute('aria-pressed', String(isFs));
      // p5 will fire windowResized, but ensure mount focus is reasonable
      const mount = document.getElementById('sketchMount');
      if (mount) mount.focus({ preventScroll: true });
    });

    function getMountSize() {
      const m = document.getElementById('sketchMount');
      if (!m) return { w: windowWidth, h: windowHeight };
      const r = m.getBoundingClientRect();
      return { w: r.width, h: r.height };
    }

    function setup() {
      const { w, h } = getMountSize();
      const c = createCanvas(w, h);
      const mount = document.getElementById('sketchMount');
      if (mount) c.parent('sketchMount');
      noStroke();
      textFont('FONT_FAMILY');
      textStyle(TEXT_ITALIC ? ITALIC : NORMAL);
      textSize(RIPPLE_TEXT_SIZE);
      textAlign(CENTER, BASELINE);
      scheduleNextRipple();

      // Optional: seed a first ripple quickly so it "breathes" on load
      setTimeout(() => {
        if (riverMask.length > 0) {
          const row = riverMask[int(riverMask.length/2)];
          if (row) triggerRipple((row.left + row.right) / 2, row.y, true);
        }
      }, 900);
    }

    function draw() {
      background(0);
      drawSunsetSky();
      drawRiver();
      drawRiverTexture();
      maybeSpawnRipple();
      drawRipples();
    }

    function windowResized() {
      const { w, h } = getMountSize();
      resizeCanvas(w, h);
    }

    /* -------- Visual layers -------- */
    function drawSunsetSky() {
      for (let y = 0; y < height; y++) {
        const inter = map(y, 0, height, 0, 1);
        const c = lerpColor(color('#fdc57b'), color('#6b4c8b'), inter);
        stroke(c);
        line(0, y, width, y);
      }
    }

    function drawRiver() {
      fill('#2f5e4e');
      beginShape();
      riverMask = [];

      for (let y = 0; y <= height; y += 8) {
        const edgeEase = sin((y / height) * PI);
        const n = noise(y * 0.01, frameCount * 0.001);
        const waveOffset = sin(y * 0.01 + frameCount * 0.003 + n * TWO_PI) * (60 + n * 30 * edgeEase);
        const leftX = width / 2 + waveOffset - RIVER_HALF_WIDTH;
        vertex(leftX, y);
        riverMask.push({ y, left: leftX });
      }

      for (let i = riverMask.length - 1; i >= 0; i--) {
        const y = riverMask[i].y;
        const edgeEase = sin((y / height) * PI);
        const n = noise(y * 0.01 + 100, frameCount * 0.001 + 100);
        const waveOffset = sin(y * 0.01 + frameCount * 0.003 + n * TWO_PI) * (60 + n * 30 * edgeEase);
        const rightX = width / 2 + waveOffset + RIVER_HALF_WIDTH;
        vertex(rightX, y);
        riverMask[i].right = rightX;
      }

      endShape(CLOSE);
    }

    function drawRiverTexture() {
      push();
      blendMode(SOFT_LIGHT);

      stroke(255, 255, 255, 12);
      strokeWeight(1);
      for (let y = 0; y < height; y += 6) {
        const waviness = sin(y * 0.02 + frameCount * 0.02) * 30;
        const left = width / 2 - RIVER_HALF_WIDTH + waviness;
        const right = width / 2 + RIVER_HALF_WIDTH + waviness;
        line(left, y, right, y);
      }

      noStroke();
      for (let i = 0; i < 30; i++) {
        const y = floor(random(height));
        const row = getMaskRowNearY(y);
        if (row) {
          const x = random(row.left, row.right);
          fill(255, 255, 255, random(20, 60));
          ellipse(x, y, random(3, 7), random(1.5, 3));
        }
      }
      pop();
    }

    /* -------- Ripple scheduling -------- */
    function scheduleNextRipple() {
      const gap = random(RIPPLE_MIN_INTERVAL_MS, RIPPLE_MAX_INTERVAL_MS);
      nextRippleAt = millis() + gap;
    }

    function maybeSpawnRipple() {
      if (millis() < nextRippleAt || riverMask.length === 0) return;

      const row = riverMask[int(random(riverMask.length))];
      if (!row || row.left === undefined || row.right === undefined) {
        scheduleNextRipple();
        return;
      }

      if (random() < RIPPLE_GROUP_CHANCE) {
        const cx = random(row.left + 18, row.right - 18);
        const cy = row.y + random(-10, 10);
        const count = int(random(RIPPLE_GROUP_SIZE_MIN, RIPPLE_GROUP_SIZE_MAX + 1));
        for (let i = 0; i < count; i++) {
          const ox = cx + random(-RIPPLE_GROUP_SPREAD, RIPPLE_GROUP_SPREAD);
          const oy = cy + random(-RIPPLE_GROUP_SPREAD, RIPPLE_GROUP_SPREAD);
          const clamped = clampToRiver(ox, oy);
          triggerRipple(clamped.x, clamped.y, i === 0);
        }
      } else {
        const x = random(row.left + 18, row.right - 18);
        triggerRipple(x, row.y, true);
      }
      scheduleNextRipple();
    }

    function triggerRipple(x, y, withText) {
      ripples.push({
        x, y,
        radius: 10,
        wobbleOffset: random(TWO_PI),
        variation: {
          freq: random(2, 5.2),
          amp: random(1.5, 4.5),
          speed: random(0.04, 0.10)
        },
        bornAt: millis(),
        phase: "fadeIn",
        alpha: 0,
        phrase: withText ? pickPhrase() : null
      });
    }

    function easeInOutCubic(t){ return t<0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2; }

// Draws “shattering” phrase where characters drift outward (radially) and wobble like water
function drawShatteringText(phrase, centerX, baselineY, ripple, now) {
  if (!phrase || phrase.length === 0) return;

  // Determine phase-based scatter strength
  let scatter = TEXT_SCATTER_HOLD;
  if (ripple.phase === 'fadeIn') {
    const t = constrain((now - ripple.bornAt) / RIPPLE_ALPHA_FADE_IN_MS, 0, 1);
    scatter = lerp(0, TEXT_SCATTER_IN, easeInOutCubic(t));
  } else if (ripple.phase === 'hold') {
    scatter = TEXT_SCATTER_HOLD;
  } else if (ripple.phase === 'fadeOut') {
    const t = constrain((now - ripple.fadeOutStart) / RIPPLE_ALPHA_FADE_OUT_MS, 0, 1);
    scatter = lerp(TEXT_SCATTER_HOLD, TEXT_SCATTER_OUT, easeInOutCubic(t));
  }

  // Radial direction from ripple center to baseline point (generally upward)
  const dx = 0;
  const dy = -1;
  const len = Math.hypot(dx, dy) || 1;
  const ux = dx / len, uy = dy / len;       // outward unit vector
  const px = -uy,   py = ux;                // perpendicular for lateral jitter

  push();
  textFont(FONT_FAMILY);
  textStyle(TEXT_ITALIC ? ITALIC : NORMAL);
  textSize(RIPPLE_TEXT_SIZE);
  noStroke();
  fill(255, ripple.alpha);

  // Measure total width to center the string
  let totalW = 0;
  for (let i = 0; i < phrase.length; i++) totalW += textWidth(phrase[i]);

  // Base left X so that text is centered at centerX
  let cursorX = centerX - totalW / 2;

  for (let i = 0; i < phrase.length; i++) {
    const ch = phrase[i];
    const chW = textWidth(ch);

    // Fraction along the word (-1 .. +1), for symmetric lateral motion
    const frac = phrase.length > 1 ? map(i, 0, phrase.length - 1, -1, 1) : 0;

    // Time-based wobble (gentle, watery)
    const wob = sin(frameCount * TEXT_WAVE_SPEED + i * 0.35 + ripple.wobbleOffset);
    const wob2 = sin(frameCount * (TEXT_WAVE_SPEED * 0.7) + i * 0.57 + ripple.wobbleOffset);

    // Outward drift scales with ripple radius & scatter
    const outward = scatter * (2 + ripple.radius * 0.015);

    // Perpendicular (along the line) drift for a “shear” effect
    const lateral = TEXT_CHAR_SPREAD * frac * (2 + wob2 * TEXT_WAVE_AMPLITUDE * 0.3);

    // Compose displacement vector
    const offX = outward * ux + lateral * px + wob * (px * 0.4 + ux * 0.2);
    const offY = outward * uy + lateral * py + wob * (py * 0.4 + uy * 0.2);

    // Slight per-char rotation
    const rot = wob * TEXT_ROTATION_MAX;

    // Draw character
    push();
    translate(cursorX + chW / 2 + offX, baselineY + offY);
    rotate(rot);
    text(ch, 0, 0);
    pop();

    cursorX += chW; // advance
  }
  pop();
}

    function drawRipples() {
      noFill();
      stroke(255, 255, 255, RIPPLE_STROKE_ALPHA);
      strokeWeight(1.2);

      const now = millis();

      for (let r of ripples) {
        const constrained = clampToRiver(r.x, r.y);
        r.x = constrained.x; r.y = constrained.y;

        push();
        translate(r.x, r.y);
        rotate(sin(frameCount * 0.03 + r.wobbleOffset) * 0.06);

        const pts = [];
        const v = r.variation;
        for (let a = 0; a < TWO_PI; a += PI / 32) {
          const wobble = sin(a * v.freq + frameCount * v.speed + r.wobbleOffset) * v.amp;
          const rx = cos(a) * (r.radius + wobble);
          const ry = sin(a) * (r.radius + wobble * 0.6);
          pts.push({ x: rx, y: ry });
        }
        beginShape();
        for (let p of pts) curveVertex(p.x, p.y);
        for (let i = 0; i < 3; i++) curveVertex(pts[i].x, pts[i].y);
        endShape();
        pop();

if (r.phrase) {
  const tNow = now; // already defined in drawRipples
  // phase handling (unchanged from your version)
  if (r.phase === "fadeIn") {
    r.alpha = map(constrain(tNow - r.bornAt, 0, RIPPLE_ALPHA_FADE_IN_MS), 0, RIPPLE_ALPHA_FADE_IN_MS, 0, 255);
    if (tNow - r.bornAt >= RIPPLE_ALPHA_FADE_IN_MS) { r.phase = "hold"; r.holdStart = tNow; r.alpha = 255; }
  } else if (r.phase === "hold") {
    r.alpha = 245;
    if (tNow - r.holdStart >= RIPPLE_ALPHA_HOLD_MS) { r.phase = "fadeOut"; r.fadeOutStart = tNow; }
  } else if (r.phase === "fadeOut") {
    const ft = tNow - r.fadeOutStart;
    r.alpha = map(constrain(ft, 0, RIPPLE_ALPHA_FADE_OUT_MS), 0, RIPPLE_ALPHA_FADE_OUT_MS, 245, 0);
  }

  if (r.alpha > 1) {
    const baselineY = r.y - r.radius - 14;
    drawShatteringText(r.phrase, r.x, baselineY, r, tNow);
  }
}


        r.radius += RIPPLE_GROWTH_PX_PER_FRAME;
      }

      ripples = ripples.filter(r => {
        if (!r.phrase) return r.radius < Math.max(width, height) * 0.8;
        return !(r.phase === "fadeOut" && r.alpha <= 1);
      });
    }

    /* -------- Utilities -------- */
    function getMaskRowNearY(y) {
      if (riverMask.length === 0) return null;
      let best = riverMask[0], bestD = Math.abs(y - best.y);
      for (let i = 1; i < riverMask.length; i++) {
        const d = Math.abs(y - riverMask[i].y);
        if (d < bestD) { best = riverMask[i]; bestD = d; }
      }
      if (best.left === undefined || best.right === undefined) return null;
      return best;
    }

    function clampToRiver(x, y) {
      const row = getMaskRowNearY(y);
      if (!row) return { x, y };
      const clampedX = constrain(x, row.left + 8, row.right - 8);
      return { x: clampedX, y: row.y };
    }

    function pickPhrase() {
      const r = Math.random();
      let pool;
      if (r < PHRASE_SETTINGS.factsWeight) pool = riverFacts;
      else if (r < PHRASE_SETTINGS.factsWeight + PHRASE_SETTINGS.brideWeight) pool = brideFlavor;
      else pool = poeticLines;

      let choice = null;
      for (let i = 0; i < 8; i++) {
        const candidate = pool[Math.floor(Math.random() * pool.length)];
        if (!recentPhrases.includes(candidate)) { choice = candidate; break; }
        choice = candidate;
      }
      recentPhrases.push(choice);
      while (recentPhrases.length > PHRASE_SETTINGS.recentBuffer) recentPhrases.shift();
      return choice;
    }
  </script>
</body>
</html>
